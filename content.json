{"meta":{"title":"H-toy","subtitle":"小晖的小伙伴","description":"小晖的Hexo博客","author":"chunhui lu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"H5_webpack_config","date":"2017-09-11T06:34:11.000Z","updated":"2017-09-11T06:34:11.000Z","comments":true,"path":"2017/09/11/H5_webpack_config/","link":"","permalink":"http://yoursite.com/2017/09/11/H5_webpack_config/","excerpt":"","text":"需求：由于经常做一些活动H5之类的小项目，自从用了webpack简直是无法自拔~好吧,我决定玩把大的，把未来做的项目全部配置到一起，要求如下： postcss 编译sass，添加浏览器厂商特有前缀 es6编译压缩打包 js，css添加hash防止缓存 html中的css、js引用需要对应其hash值 devServer实时编译 文件目录结构打包成如下的样式 1234567891011121314151617181920212223242526272829303132.├── dist│ ├── VIP│ │ ├── VIP.5c78c.css│ │ ├── VIP.5c78c.js│ │ └── index.html│ └── test│ ├── index.html│ ├── test.5c78c.css│ └── test.5c78c.js├── package.json├── pages│ ├── VIP│ │ ├── html│ │ │ └── VIP.html│ │ ├── images│ │ ├── index.js│ │ ├── js│ │ │ └── vip1.js│ │ └── sass│ │ └── index.scss│ └── test│ ├── html│ │ └── test.html│ ├── images│ ├── index.js│ ├── js│ │ └── test.js│ └── sass│ └── test.scss├── postcss.config.js└── webpack.config.js 插个题外话这个tree挺牛逼的，之前一直不知道是怎么生成的，原来是shell命令生成的，brew install tree 全局安装tree，cd 你想要生成tree的目录路径，然后在shell中执行tree，切记别瞎搞，电脑会被你玩坏的，几万个tree生成出来就呵呵了。 -dlink12```tree -L 2 //生成两层目录 -I \"node_modules\"//忽略“node_modules”文件夹```1234567891011121314OK！话不多说~干起来！（为了好理解，每次上代码的时候都只会上所有当前代码）```jsnpm init //初始化项目，创建package.jsonnpm install --save-dev webpack //安装webpack//手动创建webpack.json.js文件并编辑 OK，现在我们准备工作已经做好了，接下来就是要做最重要的事情了，那就是配置webpack，首先我们先写下常用的webpack写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const path = require('path');const ExtractTextPlugin = require(\"extract-text-webpack-plugin\");module.exports = &#123; entry : './index.js',//只是给你们看下常见的写法，其实我并没有这个文件 /* //这是多入口文件的写法 entry:&#123; a:'./a.js', b:'./b.js', ... &#125;, */ output : &#123; path : path.resolve(__dirname,'dist'), filename : '[name].js', &#125;, module : &#123; rules: [ &#123; test : /\\.js$/, exclude: /node_modules/, use : ['babel-loader'], &#125;, &#123; test : /\\.(scss|sass|less|css)$/, exclude: /node_modules/, //下面的ExtractTextPlugin的作用是将css提取出来作为单独的css文件使用 use : ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use : [ &#123; loader: 'css-loader' &#125;, &#123; loader : 'postcss-loader', &#125; ] &#125;) &#125; ] &#125;, plugins: [ //new 一个 ExtractTextPlugin的实例对象来实现提取css的功能 new ExtractTextPlugin('[name].css') ]&#125; 其实上面的代码基本上够平常使用（图片，字体啥的暂时不考虑），但是上面的配置代码完全不能满足我的需求，因为我想每做一个小项目就新加一个文件夹，文件夹中有sass,images,js,html等，并要求打包后的文件目录也是这样的，目的是给后端的小伙伴们的时候直接给他们就可以了，就像最上面的tree结构一样，Ok，我们来补充其他需要的配置代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const webpack = require('webpack');const path = require('path');//作用：匹配文件const glob = require('glob');//作用：自动安装比如js中的require、import的未安装的依赖const NpmInstallPlugin = require('npm-install-webpack-plugin');//作用：提取css文件const ExtractTextPlugin = require(\"extract-text-webpack-plugin\");//作用：清空打包后的目录（比如：dist），因为webpack不能清除的知道你需要哪个文件，当再次编译的时候它只能保留历史的并生成新的文件，所以需要手动clearconst CleanWebpackPlugin = require('clean-webpack-plugin');//动态获取所有入口文件const getEntries = () =&gt; &#123; let obj = &#123;&#125;; glob.sync('./pages/*').forEach(item =&gt; &#123; obj[`$&#123;item.split('/').pop()&#125;`] = `$&#123;item&#125;/index.js`; &#125;) return obj;&#125;module.exports = &#123; //使用函数返回的多个动态入口 entry : getEntries(), output : &#123; //需要生成的文件所在的目录 path : path.resolve(__dirname,'dist'), //带有5位hash值的文件名称 filename : './[name]/[name].[hash:5].js', publicPath: '/' &#125;, module : &#123; rules: [ &#123; test : /\\.js$/, exclude: /node_modules/, use : ['babel-loader'], &#125;, &#123; test : /\\.(scss|sass|less|css)$/, exclude: /node_modules/, use : ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use : [ &#123; loader: 'css-loader' &#125;, &#123; loader : 'postcss-loader', &#125; ] &#125;) &#125; ] &#125;, plugins: [ // 自动安装依赖实例 new NpmInstallPlugin(), // 清空dist目录实例 new CleanWebpackPlugin(['dist']), /* 提取并生成css的实例，之前在这里被坑了一次，其实控制css的输出在下面这行代码，并不是在上面的entry和output */ new ExtractTextPlugin('./[name]/[name].[hash:5].css') ]&#125; 好了，现在我们已经完成了前三个需求了（postcss 编译sass，添加浏览器厂商特有前缀、es6编译压缩打包、js，css添加hash防止缓存），接下来我们来完成最后的几个需求，贴代码先： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const webpack = require('webpack');const path = require('path');//作用：匹配文件const glob = require('glob');//作用：自动安装比如js中的require、import的未安装的依赖const NpmInstallPlugin = require('npm-install-webpack-plugin');//作用：提取css文件const ExtractTextPlugin = require(\"extract-text-webpack-plugin\");//作用：清空打包后的目录（比如：dist），因为webpack不能清除的知道你需要哪个文件，当再次编译的时候它只能保留历史的并生成新的文件，所以需要手动clearconst CleanWebpackPlugin = require('clean-webpack-plugin');//作用：生成HTML模板（特别是生成带有hash值的css和js的html文件特别有用）const HtmlWebpackPlugin = require('html-webpack-plugin');//webpack服务const webpackDevServer = require('webpack-dev-server');//动态获取所有入口文件const getEntries = () =&gt; &#123; let obj = &#123;&#125;; glob.sync(path.join(__dirname, './pages/*'), &#123;&#125;).forEach(item =&gt; &#123; obj[`$&#123;item.split('/').pop()&#125;`] = `$&#123;item&#125;/index.js`; &#125;) return obj;&#125;module.exports = &#123; //使用函数返回的多个动态入口 entry : getEntries(), output : &#123; //指定生成的文件所在的目录 path : path.resolve(__dirname, 'dist'), //带有5位hash值的文件名称 filename : './[name]/[name].[hash:5].js', publicPath: '/' &#125;, module : &#123; rules: [ &#123; test : /\\.js$/, exclude: /node_modules/, use : ['babel-loader'], &#125;, &#123; test : /\\.(scss|sass|less|css)$/, exclude: /node_modules/, use : ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use : [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'postcss-loader', &#125; ] &#125;) &#125;, //编译html文件，HtmlWebpackPlugin需要配合html-loader使用，否则。。。。你见过红色的字字么？ &#123; test : /\\.html$/, exclude: /node_modules/, use : ['html-loader'] &#125; ] &#125;, devServer: &#123; //告诉服务器从哪里提供内容 contentBase: path.resolve(__dirname, 'dist'), //是否压缩 compress : true, //指定端口号 port : 9000, publicPath : '/', &#125;, plugins : [ // 启用 HMR（即webpack的热加载插件） new webpack.HotModuleReplacementPlugin(), /* * 生成带有hash的css、js引用的html文件实例 * filename：指定要生成的html文件 * template：生成html的模板（这里有个坑提一下：网上说这个template是用于执行模板文件，比如ejs、jade等模板文件，都是指定空的模板文件，但是我明明html都写了一半了，编译一次你就给我清空了？MMP！其实这里是可以指定你的原始html文件当做模板的，这样就可以一边写一边编译了，哈哈~麻麻再也不用担心我的html被清空了） * chunks：指定需要的块，比如下面的test就需要test里面的css、js啥的，就可以直接给个['test']就可以了 * * 但是~~~~~~~ HtmlWebpackPlugin好像不能动态添加多个实例，只能这样傻逼式的手动添加，也许是我没找到方法吧，如果有知道的小伙伴教下俺 * */ new HtmlWebpackPlugin(&#123; filename: './test/index.html', template: './pages/test/html/test.html', chunks : ['test'] &#125;), new HtmlWebpackPlugin(&#123; filename: './VIP/index.html', template: './pages/VIP/html/VIP.html', chunks: ['VIP'] &#125;), // 自动安装依赖实例 new NpmInstallPlugin(), // 清空dist文件夹 new CleanWebpackPlugin(['dist']), // 提取并生成css的实例，之前在这里被坑了一次，其实控制css的输出在下面这行代码，并不是在上面的entry和output new ExtractTextPlugin('./[name]/[name].[hash:5].css'), ]&#125; Tips:1.webpack-dev-server编译后的代码其实是编译到内存中的，所以看不到打包后的dist目录,如果开发完成了，可以再执行一次生产环境的压缩，比如直接执行webpack即可,顺便贴上笔者的package.json的部分配置1234&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server --open&quot;, &quot;build&quot;:&quot;webpack&quot; &#125;, 2.比如你想看之前test/test.html的页面可直接访问 http://localhost:9000/test/index.html 好了，现在我们的需求就全部完成了！ ==今天遇到个问题，记录一下== 动态使用HtmlWebpackPlugin添加多页面实例 OK，上代码先，==由于下面的配置针对的是真实项目，所以和之前的文件夹名不太一样，请忽略== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113const webpack = require('webpack');const _path = require('path');//作用：匹配文件const glob = require('glob');//作用：自动安装比如js中的require、import的未安装的依赖const NpmInstallPlugin = require('npm-install-webpack-plugin');//作用：提取css文件const ExtractTextPlugin = require(\"extract-text-webpack-plugin\");//作用：清空打包后的目录（比如：dist），因为webpack不能清除的知道你需要哪个文件，当再次编译的时候它只能保留历史的并生成新的文件，所以需要手动clearconst CleanWebpackPlugin = require('clean-webpack-plugin');//作用：生成HTML模板（特别是生成带有hash值的css和js的html文件特别有用）const HtmlWebpackPlugin = require('html-webpack-plugin');//webpack服务const webpackDevServer = require('webpack-dev-server');//动态获取所有入口文件const getEntries = () =&gt; &#123; let obj = &#123;&#125;; glob.sync(_path.join(__dirname, './pages/*'), &#123;&#125;).forEach(item =&gt; &#123; obj[`$&#123;item.split('/').pop()&#125;`] = `$&#123;item&#125;/index.js`; &#125;) return obj;&#125;//获取image的当前路径const getImagePath = (p) =&gt; &#123; console.log(p); return p.split('/').splice(0, 1).join('/');&#125;const webpackConfig = &#123; //使用函数返回的多个动态入口 entry: getEntries(), output: &#123; //指定生成的文件所在的目录 path: _path.resolve(__dirname, 'dist'), //带有5位hash值的文件名称 filename: './[name]/[name].[hash:5].js', publicPath: '/' &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, use: ['babel-loader'], &#125;, &#123; test: /\\.(scss|sass|less|css)$/, exclude: /node_modules/, use: ['style-loader', 'css-loader', 'postcss-loader', 'sass-loader'] &#125;, //编译html文件，HtmlWebpackPlugin需要配合html-loader使用，否则。。。。你见过红色的提示么？ &#123; test: /\\.html$/, exclude: /node_modules/, use: ['html-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|svg)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 1024, // name:`./$&#123;getImagePath([path])&#125;/[name].[ext]` &#125; &#125; ] &#125; ] &#125;, devServer: &#123; //告诉服务器从哪里提供内容 contentBase: _path.resolve(__dirname, '/dist'), //需要跟new webpack.HotModuleReplacementPlugin()一起使用 hot: true, publicPath: '/', &#125;, plugins: [ // 启用 HMR（即webpack的热加载插件） new webpack.HotModuleReplacementPlugin(), // 自动安装依赖实例 new NpmInstallPlugin(), // 清空dist文件夹 new CleanWebpackPlugin(['dist']), new ExtractTextPlugin('./[name]/[name].[hash:5].css') ]&#125;//动态获取html的入口集合const getHtmlPluginsConfig = (() =&gt; &#123; //遍历路径，动态添加filename、template、chunks glob.sync('./pages/*/html/*', &#123;&#125;).forEach(item =&gt; &#123; /* HtmlWebpackPlugin作用： * 生成带有hash的css、js引用的html文件实例 * filename：指定要生成的html文件 * template：生成html的模板（这里有个坑提一下：网上说这个template是用于执行模板文件，比如ejs、jade等模板文件，都是指定空的模板文件，但是我明明html都写了一半了，编译一次你就给我清空了？MMP！其实这里是可以指定你的原始html文件当做模板的，这样就可以一边写一边编译了，哈哈~麻麻再也不用担心我的html被清空了） * chunks：指定需要的块，比如下面的test就需要test里面的css、js啥的，就可以直接给个['test']就可以了 */ const htmlPlugin = new HtmlWebpackPlugin(&#123; //这是期望的路径(eg:'./insurance/index.html') filename: item.replace(/\\/html|\\/pages/gi, () =&gt; &#123; return '' &#125;), //拿到我们的原始模板(eg:'./pages/insurance/html/index.html') template: item, //模块名（eg:'insurance'） chunks: item.split('/')[item.split('/').length - 2] &#125;); webpackConfig.plugins.push(htmlPlugin); &#125;)&#125;)();module.exports = webpackConfig; 这里说几点little tips： 1.要想真正的热更新需要devServer里的hot参数和HotModuleReplacementPlugin一起使用2.glob.sync(‘./pages//html/‘, {})这里最好用相对路径，用绝对路径在地址栏直接 http://localhost:8081/insurance/traffic.html 就会 Cannot GET /insurance/traffic.html","categories":[],"tags":[]}]}